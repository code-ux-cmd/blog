<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/blog/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/blog/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/blog/images/logo.svg" color="#222">
  <link rel="manifest" href="/blog/images/manifest.json">
  <meta name="msapplication-config" content="/blog/images/browserconfig.xml">

<link rel="stylesheet" href="/blog/css/main.css">


<link rel="stylesheet" href="/blog/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"gitee.com","root":"/blog/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="面试题总结">
<meta property="og:type" content="article">
<meta property="og:title" content="面试题">
<meta property="og:url" content="https://gitee.com/SHUAI_code/blog.git/2020/10/20/images/%E9%9D%A2%E8%AF%95%E9%A2%98/index.html">
<meta property="og:site_name" content="哼着我的小调调">
<meta property="og:description" content="面试题总结">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2020-10-20T04:55:54.114Z">
<meta property="article:modified_time" content="2020-11-08T07:50:54.029Z">
<meta property="article:author" content="白小纯">
<meta property="article:tag" content="面试题">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://gitee.com/SHUAI_code/blog.git/2020/10/20/images/%E9%9D%A2%E8%AF%95%E9%A2%98/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>面试题 | 哼着我的小调调</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/blog/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">哼着我的小调调</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">个人学习与分享</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/blog/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/blog/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/blog/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/blog/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/blog/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://gitee.com/SHUAI_code/blog.git/2020/10/20/images/%E9%9D%A2%E8%AF%95%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.jpg">
      <meta itemprop="name" content="白小纯">
      <meta itemprop="description" content="不忘初心，方得始终">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="哼着我的小调调">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          面试题
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-10-20 12:55:54" itemprop="dateCreated datePublished" datetime="2020-10-20T12:55:54+08:00">2020-10-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-11-08 15:50:54" itemprop="dateModified" datetime="2020-11-08T15:50:54+08:00">2020-11-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/" itemprop="url" rel="index"><span itemprop="name">面试题</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>17k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>15 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>面试题总结</p>
<a id="more"></a>

<h1 id="面试复习"><a href="#面试复习" class="headerlink" title="面试复习"></a>面试复习</h1><h2 id="java基础"><a href="#java基础" class="headerlink" title="java基础"></a>java基础</h2><h3 id="面向对象和面向过程的区别"><a href="#面向对象和面向过程的区别" class="headerlink" title="面向对象和面向过程的区别"></a>面向对象和面向过程的区别</h3><p><strong>首先是面试过程：</strong></p>
<p><strong>优点</strong>：性能比面向对象高，因为面向对象中类调用时需要实例化，实例化的过程比较耗费资源，开销比较大。</p>
<p><strong>缺点</strong>： 没有面向对象易维护、易复用、易扩展 </p>
<p><strong>然后就是面试对象</strong></p>
<p><strong>优点：</strong> 易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特 性，可以设计出低耦合的系统，使系统更加灵活、更加易于维护 </p>
<p><strong>缺点</strong>： 性能比面向过程低 </p>
<h3 id="Java-语言有哪些特点"><a href="#Java-语言有哪些特点" class="headerlink" title="Java 语言有哪些特点"></a>Java 语言有哪些特点</h3><ul>
<li>简单易学； </li>
<li>面向对象（封装，继承，多态）； </li>
<li>平台无关性（ Java 虚拟机实现平台无关性）； </li>
<li>可靠性； </li>
<li>安全性；</li>
<li>支持多线程（ C++ 语言没有内置的多线程机制，因此必须调用操作系 统的多线程功能来进行多线程程序设计，而 Java 语言却提供了多线程 支持）； </li>
<li>支持网络编程并且很方便（ Java 语言诞生本身就是为简化网络编程设 计的，因此 Java 语言不仅支持网络编程而且很方便）； </li>
<li>编译与解释并存</li>
</ul>
<h3 id="关于-JVM-JDK-和-JRE-最详细通俗的解答"><a href="#关于-JVM-JDK-和-JRE-最详细通俗的解答" class="headerlink" title="关于 JVM JDK 和 JRE 最详细通俗的解答"></a>关于 JVM JDK 和 JRE 最详细通俗的解答</h3><p><strong>JVM</strong><br>Java虚拟机（JVM）是运行 Java 字节码的虚拟机。JVM有针对不同系统的特 定实现（Windows，Linux，macOS），目的是使用相同的字节码（在 Java 中，JVM可以理解的代码就叫做字节码（即扩展名为 .class 的文 件）），它们都会给 出相同的结果。字节码和不同系统的 JVM 实现是 Java 语言“一次编 译，随处可以运行”的关键所在。 </p>
<p><strong>JDK 和 JRE</strong> </p>
<p>JDK是Java Development Kit，它是功能齐全的Java SDK。它拥有JRE所拥有 的一切，还有编译器（javac）和工具（如javadoc和jdb）。它能够创建和编 译程序。 </p>
<p>JRE 是 Java运行时环境。它是运行已编译 Java 程序所需的所有内容的集合， 包括 Java虚拟机（JVM），Java类库，java命令和其他的一些基础构件。但 是，它不能用于创建新程序。 </p>
<h3 id="Oracle-JDK-和-OpenJDK-的对比"><a href="#Oracle-JDK-和-OpenJDK-的对比" class="headerlink" title="Oracle JDK 和 OpenJDK 的对比"></a>Oracle JDK 和 OpenJDK 的对比</h3><ul>
<li>Oracle JDK版本将每三年发布一次，而OpenJDK版本每三个月发布一 次； </li>
<li>OpenJDK 是一个参考模型并且是完全开源的，而Oracle JDK是 OpenJDK的一个实现，并不是完全开源的； </li>
<li>Oracle JDK 比 OpenJDK 更稳定。OpenJDK和Oracle JDK的代码几乎 相同，但Oracle JDK有更多的类和一些错误修复。</li>
<li>顶级公司正在使用Oracle JDK，例如Android Studio，Minecraft和 IntelliJ IDEA开发工具，其中Open JDK不太受欢迎； </li>
<li>在响应性和JVM性能方面，Oracle JDK与OpenJDK相比提供了更好的 性能； </li>
<li>Oracle JDK不会为即将发布的版本提供长期支持，用户每次都必须通过 更新到最新版本获得支持来获取最新版本； </li>
<li>Oracle JDK根据二进制代码许可协议获得许可，而OpenJDK根据GPL v2许可获得许可。 </li>
</ul>
<h3 id="Java和C-的区别"><a href="#Java和C-的区别" class="headerlink" title="Java和C++的区别"></a>Java和C++的区别</h3><ul>
<li>都是面向对象的语言，都支持封装、继承和多态 </li>
<li>Java 不提供指针来直接访问内存，程序内存更加安全 </li>
<li>java 的类是单继承的，C++ 支持多重继承；虽然 Java 的类不可以多 继承，但是接口可以多继承。 </li>
<li>Java 有自动内存管理机制，不需要程序员手动释放无用内存 </li>
</ul>
<h3 id="什么是-Java-程序的主类-应用程序和小程序的主-类有何不同"><a href="#什么是-Java-程序的主类-应用程序和小程序的主-类有何不同" class="headerlink" title="什么是 Java 程序的主类 应用程序和小程序的主 类有何不同"></a>什么是 Java 程序的主类 应用程序和小程序的主 类有何不同</h3><p>一个程序中可以有多个类，但只能有一个类是主类。在 Java 应用程序中，这 个主类是指包含 main（）方法的类。而在 Java 小程序中，这个主类是一个继 承自系统类 JApplet 或 Applet 的子类。应用程序的主类不一定要求是 public 类，但小程序的主类要求必须是 public 类。主类是 Java 程序执行的入口点。</p>
<h3 id="什么是-Java-虚拟机？为什么-Java-被称作是“平台无关的编程语言”？"><a href="#什么是-Java-虚拟机？为什么-Java-被称作是“平台无关的编程语言”？" class="headerlink" title="什么是 Java 虚拟机？为什么 Java 被称作是“平台无关的编程语言”？"></a>什么是 Java 虚拟机？为什么 Java 被称作是“平台无关的编程语言”？</h3><p>Java 虚拟机是一个可以执行 Java 字节码的虚拟机进程。Java 源文件被编译成能被 Java 虚拟 机执行的字节码文件。</p>
<p> Java 被设计成允许应用程序可以运行在任意的平台，而不需要程序员为每一个平台单独重写 或者是重新编译。Java 虚拟机让这个变为可能，因为它知道底层硬件平台的指令长度和其特性。 </p>
<h3 id="”static”关键字是什么意思？Java-中是否可以覆盖-override-一个-private-或者是-static-的方法？"><a href="#”static”关键字是什么意思？Java-中是否可以覆盖-override-一个-private-或者是-static-的方法？" class="headerlink" title="”static”关键字是什么意思？Java 中是否可以覆盖(override)一个 private 或者是 static 的方法？"></a>”static”关键字是什么意思？Java 中是否可以覆盖(override)一个 private 或者是 static 的方法？</h3><p>“static”关键字表明一个成员变量或者是成员方法可以在没有所属的类的实例变量的情况下被访问。 </p>
<p>Java 中 static 方法不能被覆盖，因为方法覆盖是基于运行时动态绑定的，而 static 方法是编 译时静态绑 定的。static 方法跟类的任何实例都不相关，所以概念上不适用。private 也是不支持覆盖的，因为私有的 成员外界是看不到的所以也就不存在覆盖的问题。</p>
<h3 id="是否可以在static环境中访问非static变量"><a href="#是否可以在static环境中访问非static变量" class="headerlink" title="是否可以在static环境中访问非static变量"></a>是否可以在static环境中访问非static变量</h3><p>static 变量在 Java 中是属于类的，它在所有的实例中的值是一样的。当类被 Java 虚拟机载入 的时候， 会对 static 变量进行初始化。如果你的代码尝试不用实例来访问非 static 的变量，编译器会报错，因 为这些变量还没有被创建出来，还没有跟任何实例关联上。 </p>
<h3 id="Java-支持的数据类型有哪些？什么是自动拆装箱？"><a href="#Java-支持的数据类型有哪些？什么是自动拆装箱？" class="headerlink" title="Java 支持的数据类型有哪些？什么是自动拆装箱？"></a>Java 支持的数据类型有哪些？什么是自动拆装箱？</h3><p>Java 语言支持的 8 中基本数据类型是： </p>
<p>整型：byte short int long </p>
<p>浮点型：float double  </p>
<p>布尔型：boolean  </p>
<p>字符型：char </p>
<p>自动装箱是 Java 编译器在基本数据类型和对应的对象包装类型之间做的一个转化。比如：把 int 转化 成 Integer，double 转化成 double，等等。反之就是自动拆箱。 </p>
<h3 id="Java-中的方法覆盖-Overriding-和方法重载-Overloading-是什么意思？"><a href="#Java-中的方法覆盖-Overriding-和方法重载-Overloading-是什么意思？" class="headerlink" title="Java 中的方法覆盖(Overriding)和方法重载(Overloading)是什么意思？"></a>Java 中的方法覆盖(Overriding)和方法重载(Overloading)是什么意思？</h3><h4 id="重写方法的规则：（方法重写也称为方法覆盖）"><a href="#重写方法的规则：（方法重写也称为方法覆盖）" class="headerlink" title="重写方法的规则：（方法重写也称为方法覆盖）"></a>重写方法的规则：（方法重写也称为方法覆盖）</h4><p>1、参数列表必须完全与被重写的方法相同，否则不能称其为重写而是重载。</p>
<p> 2、返回的类型必须一直与被重写的方法的返回类型相同，否则不能称其为重写而是重载。</p>
<p> 3、访问修饰符的限制一定要大于被重写方法的访问修饰符（public&gt;protected&gt;default&gt;private） </p>
<p>4、重写方法一定不能抛出新的检查异常或者比被重写方法申明更加宽泛的检查型异常。例如： 父类的一个方法申明了一个检查异常 IOException，在重写这个方法是就不能抛出 Exception,只能抛出 IOException 的子类异常，可以抛出非检查异常。</p>
<h4 id="而重载的规则"><a href="#而重载的规则" class="headerlink" title="而重载的规则"></a>而重载的规则</h4><p>1、必须具有不同的参数列表；</p>
<p>2、可以有不责骂的返回类型，只要参数列表不同就可以了； </p>
<p>3、可以有不同的访问修饰符； </p>
<p>4、可以抛出不同的异常</p>
<h4 id="重写与重载的区别在于"><a href="#重写与重载的区别在于" class="headerlink" title="重写与重载的区别在于"></a>重写与重载的区别在于</h4><p>重写多态性起作用，对调用被重载过的方法可以大大减少代码的输入量，同一个方法名只要往里面传递不 同的参数就可以拥有不同的功能或返回值。 </p>
<p>用好重写和重载可以设计一个结构清晰而简洁的类，可以说重写和重载在编写代码过程中的作用非同一般</p>
<h3 id="Java-中，什么是构造函数？什么是构造函数重载？什么是复制构造函数？"><a href="#Java-中，什么是构造函数？什么是构造函数重载？什么是复制构造函数？" class="headerlink" title="Java 中，什么是构造函数？什么是构造函数重载？什么是复制构造函数？"></a>Java 中，什么是构造函数？什么是构造函数重载？什么是复制构造函数？</h3><p>当新对象被创建的时候，构造函数会被调用。每一个类都有构造函数。在程序员没有给类提 供构造函数的情况下，Java 编译器会为这个类创建一个默认的构造函数。 </p>
<p>Java 中构造函数重载和方法重载很相似。可以为一个类创建多个构造函数。每一个构造函数 必须有它自 己唯一的参数列表。 </p>
<p>Java 不支持像 C++中那样的复制构造函数，这个不同点是因为如果你不自己写构造函数的情况下，Java 不 会创建默认的复制构造函数。 </p>
<h3 id="Java-支持多继承么？支持多实现吗？"><a href="#Java-支持多继承么？支持多实现吗？" class="headerlink" title="Java 支持多继承么？支持多实现吗？"></a>Java 支持多继承么？支持多实现吗？</h3><p>不支持，Java 不支持多继承。每个类都只能继承一个类，但是可以实现多个接口。 </p>
<h3 id="接口可以继承接口吗？如果可以继承-请列举一个案例？"><a href="#接口可以继承接口吗？如果可以继承-请列举一个案例？" class="headerlink" title="接口可以继承接口吗？如果可以继承 请列举一个案例？"></a>接口可以继承接口吗？如果可以继承 请列举一个案例？</h3><p>可以，List 继承 Collection </p>
<h3 id="接口和抽象类的区别是什么？"><a href="#接口和抽象类的区别是什么？" class="headerlink" title="接口和抽象类的区别是什么？"></a>接口和抽象类的区别是什么？</h3><p>接口和抽象类有什么区别 </p>
<p>你选择使用接口和抽象类的依据是什么？ </p>
<p>接口和抽象类的概念不一样。接口时对动作的抽象，抽象类是对根源的抽象。</p>
<p>抽象类表示的是，这个对象是什么。接口表示的是，这个对象能做什么。</p>
<h4 id="接口和抽象的区别："><a href="#接口和抽象的区别：" class="headerlink" title="接口和抽象的区别："></a><strong>接口和抽象的区别：</strong></h4><p>第一点．接口是抽象类的变体，接口中所有的方法都是抽象的。而抽象类是声明方法的存在而不去实现它 的类。 </p>
<p>第二点．接口可以多继承，抽象类不行 </p>
<p>第三点．接口定义方法，不能实现，而抽象类可以实现部分方法。</p>
<p> 第四点．接口中基本数据类型为 static 而抽类象不是的。 </p>
<p>第五点．Java 接口中声明的变量默认都是 final 的。抽象类可以包含非 final 的变量。 </p>
<p>第六点．Java 接口中的成员函数默认是 public 的。抽象类的成员函数可以是 private，protected 或者 是 public。 </p>
<p>当关注一个事物的本质的时候，用抽象类；当关注一个操作的时候，用接口。</p>
<p>抽象类的功能虽然远超过接口，但是定义抽象类的代价高。因为java中每个类只能继承一个类。在这个类中，你必须继承或编写出其所有子类的所有共性。虽然接口在功能上会弱化很多，但是它只是针对一个动作的描述。而且你可以在一个类中同时实现多个接口。在设计阶段会降低难度的。 </p>
<p>接口是绝对抽象的，不可以被实例化。抽象类也不可以被实例化。</p>
<h3 id="什么是值传递和引用传递"><a href="#什么是值传递和引用传递" class="headerlink" title="什么是值传递和引用传递"></a>什么是值传递和引用传递</h3><p>对象被值传递，意味着传递了对象的一个副本。因此，就算是改变了对象副本，也不会影响 源对象的值。 </p>
<p>对象被引用传递，意味着传递的并不是实际的对象，而是对象的引用。因此，外部对引用对 象所做的改变 会反映到所有的对象上。 </p>
<h3 id="int-和-Integer-有什么区别"><a href="#int-和-Integer-有什么区别" class="headerlink" title="int 和 Integer 有什么区别"></a>int 和 Integer 有什么区别</h3><p>java提供了两种不同的类型：引用类型和原始类型。</p>
<p><strong>Int</strong>是<strong>java</strong>的原始数据类型，Integer是java为i nt提供的封装类。Java为每个原始类型提供了封装类。 </p>
<h3 id="String和StringBuffer的区别"><a href="#String和StringBuffer的区别" class="headerlink" title="String和StringBuffer的区别"></a>String和StringBuffer的区别</h3><p><strong>String</strong>是不可变数据类型，底层是用<strong>final</strong>修饰的变量，数据第一次赋值之后如果进行第二次赋值，那么会创建一个新的对象，占用jvm的内存空间。</p>
<p><strong>StringBuffer</strong> 是可变数据类型，底层是使用的byte数组存贮字符串，可以在原有的字符串的基础上对字符串进行操作。</p>
<h3 id="运行时异常和一般异常有何不同"><a href="#运行时异常和一般异常有何不同" class="headerlink" title="运行时异常和一般异常有何不同"></a>运行时异常和一般异常有何不同</h3><p>运行时异常表示虚拟机的通常操作中可能遇到的异常，是一种常见的运行错误。java编译器要求方法必须声明抛出可能发生的非运行时异常，但是并不要求必须抛出未被捕获的运行时异常。</p>
<h3 id="final-finally-finalize的区别。"><a href="#final-finally-finalize的区别。" class="headerlink" title="final, finally, finalize的区别。"></a>final, finally, finalize的区别。</h3><p> final 用于声明属性，方法和类，分别表示属性不可变，方法不可覆盖，类不可继承。</p>
<p>finally是异常处理语句 结构的一部分，表示总是执行。</p>
<p>finalize是Object类的一个方法，在垃圾收集器执行的时候会调用被回 收对象的此方法，可以覆盖此方法提供垃圾收集时的其他资源回收，例如关闭文件等。</p>
<h3 id="Overload和Override的区别。"><a href="#Overload和Override的区别。" class="headerlink" title="Overload和Override的区别。"></a>Overload和Override的区别。</h3><p>方法的重写Overriding和重载Overloading是Java多态性的不同表现。</p>
<p>重写Override是父类与子类之间 多态性的一种表现，重载Overload是一个类中多态性的一种表现。如果在子类中定义某方法与其父 类有相同的名称和参数，我们说该方法被重写 (Override)。子类的对象使用这个方法时，将调用子类中的定义，对它而言，父类中的定义如同被“屏 蔽”了。如果在一个类中定义了多个同名的方法，它们或有不同的参数个数或有不同的参数类型，则称 为方法的重载(Overloading)。Overloaded的方法是可以改变返回值的类型。</p>
<h3 id="swtich是否能作用在byte上，是否能作用在long上，是否能作用在String上"><a href="#swtich是否能作用在byte上，是否能作用在long上，是否能作用在String上" class="headerlink" title="swtich是否能作用在byte上，是否能作用在long上，是否能作用在String上?"></a>swtich是否能作用在byte上，是否能作用在long上，是否能作用在String上?</h3><p>switch（expr1）中，expr1 是一个整数表达式。因此传递给 switch 和 case 语句的参数应该是 int、 short、 char 或者 byte。long,string 都不能作用于swtich。</p>
<h3 id="char型变量中能不能存贮一个中文汉字-为什么"><a href="#char型变量中能不能存贮一个中文汉字-为什么" class="headerlink" title="char型变量中能不能存贮一个中文汉字?为什么?"></a>char型变量中能不能存贮一个中文汉字?为什么?</h3><p>能够定义成为一个中文的，因为java中以unicode编码，一个char占16个字节，所以放一个中文是没问题的</p>
<h3 id="java中有几种类型的流？"><a href="#java中有几种类型的流？" class="headerlink" title="java中有几种类型的流？"></a>java中有几种类型的流？</h3><p>JDK为每种类型的流提供了一些抽象类以供继承，请说出他们分别是哪 些类？ 字节流，字符流。字节流继承于InputStream \ OutputStream，字符流继承于InputStreamReader \ OutputStreamWriter。在java.io包中还有许多其他的流，主要是为了提高性能和使用方便。</p>
<h3 id="什么是java序列化，如何实现java序列化？"><a href="#什么是java序列化，如何实现java序列化？" class="headerlink" title="什么是java序列化，如何实现java序列化？"></a>什么是java序列化，如何实现java序列化？</h3><p>序列化就是一种用来处理对象流的机制，所谓对象流也就是将对象的内容进行流化。可以对流化后的 对象进行读写操作，也可将流化后的对象传输于网络之间。序列化是为了解决在对对象流进行读写操 作时所引发的问题。序列化的实现：将需要被序列化的类实现Serializable接口，该接口没有需要实现的 方法，implements Serializable只是为了标注该对象是可被序列化的，然后使用一个输出流(如：FileOutputStream)来构造 一个ObjectOutputStream(对象流)对象，接着，使用ObjectOutputStream对象的writeObject(Object obj)方法就可以将参数为obj的对象写出(即保存其状态)，要恢复的话则用输入流。</p>
<h3 id="是否可以从一个static方法内部发出对非static方法的调用？"><a href="#是否可以从一个static方法内部发出对非static方法的调用？" class="headerlink" title="是否可以从一个static方法内部发出对非static方法的调用？"></a>是否可以从一个static方法内部发出对非static方法的调用？</h3><p>不可以,如果其中包含对象的method() ；不能保证对象初始化.</p>
<h2 id="线程与进程"><a href="#线程与进程" class="headerlink" title="线程与进程"></a>线程与进程</h2><h3 id="进程和线程的区别是什么？"><a href="#进程和线程的区别是什么？" class="headerlink" title="进程和线程的区别是什么？"></a>进程和线程的区别是什么？</h3><p>进程是执行着的应用程序，而线程是进程内部的一个执行序列。一个进程可以有多个线程。 线程又叫做轻量级进程。 </p>
<h3 id="创建线程有几种不同的方式？你喜欢哪一种？为什么？"><a href="#创建线程有几种不同的方式？你喜欢哪一种？为什么？" class="headerlink" title="创建线程有几种不同的方式？你喜欢哪一种？为什么？"></a>创建线程有几种不同的方式？你喜欢哪一种？为什么？</h3><p>有三种方式可以用来创建线程： </p>
<p>继承 Thread 类 </p>
<p>实现 Runnable 接口 </p>
<p>应用程序可以使用 Executor 框架来创建线程池 </p>
<p>实现 Runnable 接口这种方式更受欢迎，因为这不需要继承 Thread 类。在应用设计中已经继承了别的对 象的情况下，这需要多继承（而 Java 不支持多继承），只能实现接口。同时，线程池也是非常高效的， 很容易实现和使用。 </p>
<h3 id="概括的解释下线程的几种可用状态。"><a href="#概括的解释下线程的几种可用状态。" class="headerlink" title="概括的解释下线程的几种可用状态。"></a>概括的解释下线程的几种可用状态。</h3><p><strong>就绪(Runnable)</strong>:线程准备运行，不一定立马就能开始执行。 </p>
<p>**运行中(Running)**：进程正在执行线程的代码。 </p>
<p><strong>等待中(Waiting)</strong>:线程处于阻塞的状态，等待外部的处理结束。</p>
<p>**睡眠中 (Sleeping)**：线程被强制睡眠。 </p>
<p>**I/O 阻塞(Blocked on I/O)**：等待 I/O 操作完成。 </p>
<p>**同步阻塞(Blocked on Synchronization)**：等待获取锁。 </p>
<p>**死亡(Dead)**：线程完成了执行。 </p>
<h3 id="同步方法和同步代码块的区别是什么？"><a href="#同步方法和同步代码块的区别是什么？" class="headerlink" title="同步方法和同步代码块的区别是什么？"></a>同步方法和同步代码块的区别是什么？</h3><p>同步方法默认使用当前类作为锁</p>
<p>同步代码块可以选择以什么来枷锁，比同步方法更加精确一些。</p>
<p>同步代码块可以选择只有会在同步发生问题的代码加锁，而不是整个方法。</p>
<p>同步方法使用sysnchronized修饰，而同步代码块使用synchronized（this）{}修饰。</p>
<h3 id="在监视器-Monitor-内部，是如何做线程同步的？程序应该做哪种级别的同步？"><a href="#在监视器-Monitor-内部，是如何做线程同步的？程序应该做哪种级别的同步？" class="headerlink" title="在监视器(Monitor)内部，是如何做线程同步的？程序应该做哪种级别的同步？"></a>在监视器(Monitor)内部，是如何做线程同步的？程序应该做哪种级别的同步？</h3><p>监视器和锁在 Java 虚拟机中是一块使用的。监视器监视一块同步代码块，确保一次只有一 个线程执行同步代码块。每一个监视器都和一个对象引用相关联。线程在获取锁之前不允许执行同步代码。 </p>
<h3 id="什么是死锁-deadlock-？"><a href="#什么是死锁-deadlock-？" class="headerlink" title="什么是死锁(deadlock)？"></a>什么是死锁(deadlock)？</h3><p>两个进程都在等待对方执行完毕才能继续往下执行的时候就发生了死锁。结果就是两个进程 都陷入了无限的等待中。</p>
<h3 id="如何确保-N-个线程可以访问-N-个资源同时又不导致死锁？"><a href="#如何确保-N-个线程可以访问-N-个资源同时又不导致死锁？" class="headerlink" title="如何确保 N 个线程可以访问 N 个资源同时又不导致死锁？"></a>如何确保 N 个线程可以访问 N 个资源同时又不导致死锁？</h3><p>使用多线程的时候，一种非常简单的避免死锁的方式就是：指定获取锁的顺序，并强制线程 </p>
<p>按照指定的顺序获取锁。因此，如果所有的线程都是以同样的顺序加锁和释放锁，就不会出 现死锁了。 </p>
<h3 id="同步和异步有何异同，在什么情况下分别使用他们？举例说明。"><a href="#同步和异步有何异同，在什么情况下分别使用他们？举例说明。" class="headerlink" title="同步和异步有何异同，在什么情况下分别使用他们？举例说明。"></a>同步和异步有何异同，在什么情况下分别使用他们？举例说明。</h3><p>如果数据将在线程间共享。例如正在写的数据以后可能被另一个线程读到，或者正在读的数据可能已 经被另一个线程写过了，那么这些数据就是共享数据，必须进行同步存取。</p>
<p>当应用程序在对象上调用 了一个需要花费很长时间来执行的方法，并且不希望让程序等待方法的返回时，就应该使用异步编程 ，在很多情况下采用异步途径往往更有效率。</p>
<h3 id="启动一个线程是用run-还是start"><a href="#启动一个线程是用run-还是start" class="headerlink" title="启动一个线程是用run()还是start()?"></a>启动一个线程是用run()还是start()?</h3><p>启动一个线程是调用start()方法，使线程所代表的虚拟处理机处 于可运行状态，这意味着它可以由JVM调度并执行。这并不意味着线程就会立即运行。run()方法可以 产生必须退出的标志来停止一个线程。</p>
<h3 id="说出数据连接池的工作机制是什么"><a href="#说出数据连接池的工作机制是什么" class="headerlink" title="说出数据连接池的工作机制是什么?"></a>说出数据连接池的工作机制是什么?</h3><p>J2EE服务器启动时会建立一定数量的池连接，并一直维持不少于此数目的池连接。客户端程序需要连接时，池驱动程序会返回一个未使用的池连接并将其表记为忙。</p>
<p>如果当前没有空闲连接，池驱动程序 就新建一定数量的连接，新建连接的数量有配置参数决定。</p>
<p>当使用的池连接调用完成后，池驱动程序 将此连接表记为空闲，其他调用就可以使用这个连接。</p>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h3 id="Java-集合类框架的基本接口有哪些？"><a href="#Java-集合类框架的基本接口有哪些？" class="headerlink" title="Java 集合类框架的基本接口有哪些？"></a>Java 集合类框架的基本接口有哪些？</h3><p>Java 集合类提供了一套设计良好的支持对一组对象进行操作的接口和类。Java 集合类里面最 基本的接口有：</p>
<p>Collection：代表一组对象，每一个对象都是它的子元素。 </p>
<p>Set：不包含重复元素的 Collection。 </p>
<p>List：有顺序的 collection，并且可以包含重复元素。  </p>
<p>Map：可以把键(key)映射到值(value)的对象，键不能重复。 </p>
<h3 id="为什么集合类没有实现-Cloneable-和-Serializable-接口？"><a href="#为什么集合类没有实现-Cloneable-和-Serializable-接口？" class="headerlink" title="为什么集合类没有实现 Cloneable 和 Serializable 接口？"></a>为什么集合类没有实现 Cloneable 和 Serializable 接口？</h3><p>集合类接口指定了一组叫做元素的对象。集合类接口的每一种具体的实现类都可以选择以它  自己的方式对元素进行保存和排序。有的集合类允许重复的键，有些不允许。 </p>
<h3 id="什么是迭代器-Iterator-？"><a href="#什么是迭代器-Iterator-？" class="headerlink" title="什么是迭代器(Iterator)？"></a>什么是迭代器(Iterator)？</h3><p>Iterator 接口提供了很多对集合元素进行迭代的方法。每一个集合类都包含了可以返回迭代  器实例的 迭代方法。迭代器可以在迭代的过程中删除底层集合的元素。   </p>
<h3 id="Iterator-和-ListIterator-的区别是什么？"><a href="#Iterator-和-ListIterator-的区别是什么？" class="headerlink" title="Iterator 和 ListIterator  的区别是什么？"></a>Iterator 和 ListIterator  的区别是什么？</h3><p>Iterator 可用来遍历 Set 和 List 集合，但是 ListIterator 只能用来遍历 List。 </p>
<p>Iterator 对集合只能是前向遍历，ListIterator 既可以前向也可以后向。  </p>
<p>ListIterator  实现了 Iterator 接口，并包含其他的功能，比如：增加元素，替换元素，获取前  一个和后一个元素的索引，等等。</p>
<h3 id="Java-中的-HashMap-的工作原理是什么？"><a href="#Java-中的-HashMap-的工作原理是什么？" class="headerlink" title="Java  中的 HashMap 的工作原理是什么？"></a>Java  中的 HashMap 的工作原理是什么？</h3><p> Java  中的 HashMap 是以键值对(key-value)的形式存储元素的。HashMap 需要一个 hash 函 数，它使用 hashCode()和 equals()方法来向集合/从集合添加和检索元素。当调用 put()方法的时  候，HashMap 会计算 key  的 hash 值，然后把键值对存储在集合中合适的索引上。如果 key  已经存在了，value 会被更新成新值。HashMap 的一些重要的特性是它的容量(capacity)，负 载 因子(load factor)和扩容极限(threshold resizing)。</p>
<h3 id="hashCode-和-equals-方法的重要性体现在什么地方？"><a href="#hashCode-和-equals-方法的重要性体现在什么地方？" class="headerlink" title="hashCode()和 equals()方法的重要性体现在什么地方？"></a>hashCode()和 equals()方法的重要性体现在什么地方？</h3><p> Java  中的 HashMap 使用 hashCode()和 equals()方法来确定键值对的索引，当根据键获取值 的时候也会用到这两个方法。如果没有正确的实现这两个方法，两个不同的键可能会有相同的  hash  值，因此，可能会被集合认为是相等的。而且，这两个方法也用来发现重复元素。所以这两个方法的实现对 HashMap 的精确性和正确性是至关重要的。 </p>
<h3 id="HashMap-和-Hashtable-有什么区别？"><a href="#HashMap-和-Hashtable-有什么区别？" class="headerlink" title="HashMap 和 Hashtable 有什么区别？"></a>HashMap 和 Hashtable 有什么区别？</h3><p>HashMap 和 Hashtable 都实现了 Map 接口，因此很多特性非常相似。但是，他们有以下不同点：</p>
<p>HashMap 允许键和值是 null，而 Hashtable 不允许键或者值是 null。  </p>
<p>Hashtable 是同步的，而 HashMap 不是。因此，HashMap 更适合于单线程环境，而 Hashtable  适合于多线程环境。 </p>
<p>HashMap  提供了可供应用迭代的键的集合，因此，HashMap 是快速失败的。另一方面，  </p>
<p>Hashtable 提供了对键的列举(Enumeration)。  一般认为 Hashtable 是一个遗留的类。 </p>
<h3 id="数组-Array-和列表-ArrayList-有什么区别？什么时候应该使用-Array-而不是ArrayList-？"><a href="#数组-Array-和列表-ArrayList-有什么区别？什么时候应该使用-Array-而不是ArrayList-？" class="headerlink" title="数组(Array)和列表(ArrayList)有什么区别？什么时候应该使用 Array 而不是ArrayList ？"></a>数组(Array)和列表(ArrayList)有什么区别？什么时候应该使用 Array 而不是ArrayList ？</h3><p>Array 可以包含基本类型和对象类型，ArrayList  只能包含对象类型。  </p>
<p>Array 大小是固定的，ArrayList  的大小是动态变化的。  </p>
<p>ArrayList  提供了更多的方法和特性，比如：addAll()，removeAll()，iterator()等等。  </p>
<p>对于基本类型数据，集合使用自动装箱来减少编码工作量。但是，当处理固定大小的基本数据类型的时候，这种方式相对比较慢。</p>
<h3 id="ArrayList-和-LinkedList-有什么区别？"><a href="#ArrayList-和-LinkedList-有什么区别？" class="headerlink" title="ArrayList 和 LinkedList 有什么区别？"></a>ArrayList 和 LinkedList 有什么区别？</h3><p><strong>ArrayList  和 LinkedList 都实现了 List 接口，他们有以下的不同点：</strong> </p>
<p>ArrayList  是基于索引的数据接口，它的底层是数组。它可以以 O(1)时间复杂度对元素进行随  机访问。</p>
<p>与此对应，LinkedList 是以元素列表的形式存储它的数据，每一个元素都和它 的前 一个和后一个元素链接在一起，在这种情况下，查找某个元素的时间复杂度是 O(n)。 </p>
<p>相对于 ArrayList ，LinkedList的插入，添加，删除操作速度更快，因为当元素被添加到集合任意位置的时候，不需要像数组那样重新计算大小或者是更新索引。  </p>
<p>LinkedList  比 ArrayList更占内存，因为 LinkedList 为每一个节点存储了两个引用，一个指 向前一个元素，一个指向下一个元素。 </p>
<h3 id="Comparable-和-Comparator-接口是干什么的？列出它们的区别。"><a href="#Comparable-和-Comparator-接口是干什么的？列出它们的区别。" class="headerlink" title="Comparable 和 Comparator 接口是干什么的？列出它们的区别。"></a>Comparable 和 Comparator 接口是干什么的？列出它们的区别。</h3><p>Java 提供了只包含一个 compareTo()方法的 Comparable 接口。这个方法可以个给两个对象排序。具体来说，它返回负数，0，正数来表明输入对象小于，等于，大于已经存在的对象。  </p>
<p>Java  提供了包含 compare()和 equals()两个方法的 Comparator 接口。compare()方法用来给两 个输入参数排序，返回负数，0，正数表明第一个参数是小于，等于，大于第二个参数。equals()  方法需要一个对象作为参数，它用来决定输入参数是否和 comparator  相等。只有当输入参  数也是一个 comparator 并且输入参数和当前 comparator  的排序结果是相同的时候，这个方  法才返回 true 。  </p>
<h3 id="什么是-Java-优先级队列-Priority-Queue-？"><a href="#什么是-Java-优先级队列-Priority-Queue-？" class="headerlink" title="什么是 Java 优先级队列(Priority Queue)？"></a>什么是 Java 优先级队列(Priority Queue)？</h3><p>PriorityQueue 是一个基于优先级堆的无界队列，它的元素是按照自然顺序(natural order)排序  的。在创建的时候，我们可以给它提供一个负责给元素排序的比较器。PriorityQueue 不允许null 值，因为他们没有自然顺序，或者说他们没有任何的相关联的比较器。最后，PriorityQueue  不是线程安全的，入队和出队的时间复杂度是 O(log(n))。 </p>
<h3 id="如何权衡是使用无序的数组还是有序的数组？"><a href="#如何权衡是使用无序的数组还是有序的数组？" class="headerlink" title="如何权衡是使用无序的数组还是有序的数组？"></a>如何权衡是使用无序的数组还是有序的数组？</h3><p>有序数组最大的好处在于查找的时间复杂度是 O(log n)，而无序数组是 O(n)。有序数组的缺 点是插入操作的时间复杂度是 O(n)，因为值大的元素需要往后移动来给新元素腾位置。相反，  无序数组的插入时间复杂度是常量 O(1)。 </p>
<h3 id="HashSet-和-TreeSet-有什么区别？"><a href="#HashSet-和-TreeSet-有什么区别？" class="headerlink" title="HashSet 和 TreeSet 有什么区别？"></a>HashSet 和 TreeSet 有什么区别？</h3><p>HashSet 是由一个 hash 表来实现的，因此，它的元素是无序的。add() ，remove()，contains()  方法的时间复杂度是 O(1)。  </p>
<p>另一方面，TreeSet  是由一个树形的结构来实现的，它里面的元素是有序的。因此，add()，  remove()，contains()方法的时间复杂度是 O(logn)。</p>
<h3 id="Set里的元素是不能重复的，那么用什么方法来区分重复与否呢-是用-还是equals-它们有何区别"><a href="#Set里的元素是不能重复的，那么用什么方法来区分重复与否呢-是用-还是equals-它们有何区别" class="headerlink" title="Set里的元素是不能重复的，那么用什么方法来区分重复与否呢? 是用==还是equals()? 它们有何区别?"></a>Set里的元素是不能重复的，那么用什么方法来区分重复与否呢? 是用==还是equals()? 它们有何区别?</h3><p>Set里的元素是不能重复的，那么用iterator()方法来区分重复与否。equals()是判读两个Set是否相等。eq uals()和==方法决定引用值是否指向同一对象equals()在类中被覆盖，为的是当两个分离的对象的内容 和类型相配的话，返回真值</p>
<h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><h3 id="Java中垃圾回收有什么目的？什么时候进行垃圾回收？"><a href="#Java中垃圾回收有什么目的？什么时候进行垃圾回收？" class="headerlink" title="Java中垃圾回收有什么目的？什么时候进行垃圾回收？"></a>Java中垃圾回收有什么目的？什么时候进行垃圾回收？</h3><p>java的垃圾回收分为三个区域：新生代 老年代 永久代</p>
<p>一个对象实例化时 先去看伊甸园有没有足够的空间<br>如果有 不进行垃圾回收 ,对象直接在伊甸园存储.<br>如果伊甸园内存已满,会进行一次minor gc<br>然后再进行判断伊甸园中的内存是否足够<br>如果不足 则去看存活区的内存是否足够.<br>如果内存足够,把伊甸园部分活跃对象保存在存活区,然后把对象保存在伊甸园.<br>如果内存不足,向老年代发送请求,查询老年代的内存是否足够<br>如果老年代内存足够,将部分存活区的活跃对象存入老年代.然后把伊甸园的活跃对象放入存活区,对象依旧保存在伊甸园.<br>如果老年代内存不足,会进行一次full gc,之后老年代会再进行判断 内存是否足够,如果足够 同上.<br>如果不足 会抛出OutOfMemoryError. </p>
<h3 id="System-gc-和-Runtime-gc-会做什么事情？"><a href="#System-gc-和-Runtime-gc-会做什么事情？" class="headerlink" title="System.gc()和 Runtime.gc()会做什么事情？"></a>System.gc()和 Runtime.gc()会做什么事情？</h3><p>System.gc();就是呼叫java虚拟机的垃圾回收器运行回收内存的垃圾。</p>
<p>每个 Java 应用程序都有一个 Runtime 类实例，使应用程序能够与其运行的环境相连接。可以通过 getRuntime 方法获取当前运行时。 Runtime.getRuntime().gc();</p>
<h3 id="Java-堆的结构是什么样子的？什么是堆中的永久代-Perm-Gen-space"><a href="#Java-堆的结构是什么样子的？什么是堆中的永久代-Perm-Gen-space" class="headerlink" title="Java 堆的结构是什么样子的？什么是堆中的永久代(Perm Gen space)?"></a>Java 堆的结构是什么样子的？什么是堆中的永久代(Perm Gen space)?</h3><p>JVM 的堆是运行时数据区，所有类的实例和数组都是在堆上分配内存。它在 JVM  启动的时 候被创建。对象所占的堆内存是由自动内存管理系统也就是垃圾收集器回收。  </p>
<p>堆内存是由存活和死亡的对象组成的。存活的对象是应用可以访问的，不会被垃圾回收。死  亡的对象是应用不可访问尚且还没有被垃圾收集器回收掉的对象。一直到垃圾收集器把这些  对象回收掉之前，他们会一直占据堆内存空间。</p>
<h3 id="串行-serial-收集器和吞吐量-throughput-收集器的区别是什么？"><a href="#串行-serial-收集器和吞吐量-throughput-收集器的区别是什么？" class="headerlink" title="串行(serial)收集器和吞吐量(throughput)收集器的区别是什么？"></a>串行(serial)收集器和吞吐量(throughput)收集器的区别是什么？</h3><p>吞吐量收集器使用并行版本的新生代垃圾收集器，它用于中等规模和大规模数据的应用程序。而串行收集器对大多数的小应用(在现代处理器上需要大概 100M 左右的内存)就足够了。 </p>
<h3 id="在-Java-中，对象什么时候可以被垃圾回收？"><a href="#在-Java-中，对象什么时候可以被垃圾回收？" class="headerlink" title="在 Java  中，对象什么时候可以被垃圾回收？"></a>在 Java  中，对象什么时候可以被垃圾回收？</h3><p>这个对象不用的时候，或者这个对象无法被调用的时候。</p>
<h3 id="JVM-的永久代中会发生垃圾回收么？"><a href="#JVM-的永久代中会发生垃圾回收么？" class="headerlink" title="JVM  的永久代中会发生垃圾回收么？"></a>JVM  的永久代中会发生垃圾回收么？</h3><p>垃圾回收不会发生在永久代，如果永久代满了或者是超过了临界值，会触发完全垃圾回收 (Full   GC)。如果你仔细查看垃圾收集器的输出信息，就会发现永久代也是被回收的。</p>
<h3 id="描述一下JVM加载class文件的原理机制"><a href="#描述一下JVM加载class文件的原理机制" class="headerlink" title="描述一下JVM加载class文件的原理机制?"></a>描述一下JVM加载class文件的原理机制?</h3><p>JVM中类的装载是由ClassLoader和它的子类来实现的,Java ClassLoader 是一个重要的Java运行时系统组件。它负责在运行时查找和装入类文件的类。</p>
<h2 id="JavaWeb"><a href="#JavaWeb" class="headerlink" title="JavaWeb"></a>JavaWeb</h2><h3 id="说出Servlet的生命周期，并说出Servlet和CGI的区别。"><a href="#说出Servlet的生命周期，并说出Servlet和CGI的区别。" class="headerlink" title="说出Servlet的生命周期，并说出Servlet和CGI的区别。"></a>说出Servlet的生命周期，并说出Servlet和CGI的区别。</h3><p>Servlet被服务器实例化后，容器运行其init方法，请求到达时运行其service方法，service方法自动派遣 运行与请求对应的doXXX方法（doGet，doPost）等，当服务器决定将实例销毁的时候调用其destroy方法 。 </p>
<p>与cgi的区别在于servlet处于服务器进程中，它通过多线程方式运行其service方法，一个实例可以服务 于多个请求，并且其实例一般不会销毁，而CGI对每个请求都产生新的进程，服务完成后就销毁，所以 效率上低于servlet。</p>
<h3 id="JSP中动态INCLUDE与静态INCLUDE的区别？"><a href="#JSP中动态INCLUDE与静态INCLUDE的区别？" class="headerlink" title="JSP中动态INCLUDE与静态INCLUDE的区别？"></a>JSP中动态INCLUDE与静态INCLUDE的区别？</h3><p>动态INCLUDE用jsp:include动作实现 <code>&lt;jsp:include page=&quot;included.jsp&quot; flush=&quot;true&quot;/&gt;</code></p>
<p>它总是会检查所含文件中的变化，适合用于包含动态页面，并且可以带参数。静态INCLUDE用inclu de伪码实现,定不会检查所含文件的变化，适用于包含静态页面<code>&lt;%@ include file=&quot;included.htm&quot; %&gt; </code></p>
<h3 id="什么时候用assert。"><a href="#什么时候用assert。" class="headerlink" title="什么时候用assert。"></a>什么时候用assert。</h3><p>assertion(断言)在软件开发中是一种常用的调试方式，很多开发语言中都支持这种机制。在实现中，ass ertion就是在程序中的一条语句，它对一个boolean表达式进行检查，一个正确程序必须保证这个boolea n表达式的值为true；如果该值为false，说明程序已经处于不正确的状态下，系统将给出警告或退出。一 般来说，assertion用于保证程序最基本、关键的正确性。assertion检查通常在开发和测试时开启。为了 提高性能，在软件发布后，assertion检查通常是关闭的。</p>
<h3 id="Java有没有goto"><a href="#Java有没有goto" class="headerlink" title="Java有没有goto?"></a>Java有没有goto?</h3><p>java中的保留字，现在没有在java中使用。</p>
<h3 id="JSP的内置对象及方法。"><a href="#JSP的内置对象及方法。" class="headerlink" title="JSP的内置对象及方法。"></a>JSP的内置对象及方法。</h3><p><strong>request</strong>：表示HttpServletRequest对象。它包含了有关浏览器请求的信息，并且提供了几个用于获取cooki e, header, 和session数据的有用的方法,response表示HttpServletResponse对象，并提供了几个用于设置送回 浏览器的响应的方法（如cookies,头信息等） </p>
<p><strong>out</strong>：对象是javax.jsp.JspWriter的一个实例，并提供了几个方法使你能用于向浏览器回送输出结果。 </p>
<p><strong>pageContext</strong>：表示一个javax.servlet.jsp.PageContext对象。它是用于方便存取各种范围的名字空间、servlet相关的对象的API，并且包装了通用的servlet相关功能的方法。</p>
<p><strong>session</strong>：表示一个请求的javax.servlet.http.HttpSession对象。Session可以存贮用户的状态信息  applicaton 表示一个javax.servle.ServletContext对象。这有助于查找有关servlet引擎和servlet环境的信息  </p>
<p><strong>config</strong> ：表示一个javax.servlet.ServletConfig对象。该对象用于存取servlet实例的初始化参数。  </p>
<p><strong>page</strong> ：表示从该页面产生的一个servlet实例</p>
<h3 id="什么情况下调用doGet-和doPost-？"><a href="#什么情况下调用doGet-和doPost-？" class="headerlink" title="什么情况下调用doGet()和doPost()？"></a>什么情况下调用doGet()和doPost()？</h3><p>Jsp页面中的form标签里的method属性为get时调用doGet()，为 post时调用doPost()。</p>
<h3 id="如何现实servlet的单线程模式"><a href="#如何现实servlet的单线程模式" class="headerlink" title="如何现实servlet的单线程模式"></a>如何现实servlet的单线程模式</h3><p>&lt;%@ page isThreadSafe=”false”%&gt;</p>
<h3 id="JSP和Servlet有哪些相同点和不同点，他们之间的联系是什么？"><a href="#JSP和Servlet有哪些相同点和不同点，他们之间的联系是什么？" class="headerlink" title="JSP和Servlet有哪些相同点和不同点，他们之间的联系是什么？"></a>JSP和Servlet有哪些相同点和不同点，他们之间的联系是什么？</h3><p>JSP是Servlet技术的扩展，本质上是Servlet的简易方式，更强调应用的外表表达。JSP编译后是”类servle t”。Servlet和JSP最主要的不同点在于，Servlet的应用逻辑是在Java文件中，并且完全从表示层中的HT ML里分离开来。而JSP的情况是Java和HTML可以组合成一个扩展名为.jsp的文件。JSP侧重于视图，Se rvlet主要用于控制逻辑。</p>
<h3 id="jsp的四种范围"><a href="#jsp的四种范围" class="headerlink" title="jsp的四种范围"></a>jsp的四种范围</h3><p><strong>page</strong>否是代表与一个页面相关的对象和属性。一个页面由一个编译好的 Java servlet 类（可以带有任何的 include 指令，但是没有 include 动作）表示。这既包括 servlet 又包括被编译成 servlet 的 JSP 页面</p>
<p><strong>request</strong>是是代表与 Web 客户机发出的一个请求相关的对象和属性。一个请求可能跨越多个页面，涉及多个 Web 组件（由于 forward 指令和 include 动作的关系） </p>
<p><strong>session</strong>是是代表与用于某个 Web 客户机的一个用户体验相关的对象和属性。一个 Web 会话可以也经常会跨越多个客户机请求 </p>
<p><strong>application</strong>是是代表与整个 Web 应用程序相关的对象和属性。这实质上是跨越整个 Web 应用程序，包括多个页面、请求和会话的一个全局作用域</p>
<h3 id="Request对象的主要方法"><a href="#Request对象的主要方法" class="headerlink" title="Request对象的主要方法"></a>Request对象的主要方法</h3><ul>
<li>setAttribute(String name,Object)：设置名字为name的request的参数值</li>
<li>getAttribute(String name)：返回由name指定的属性值 </li>
<li>getAttributeNames()：返回request对象所有属性的名字集合，结果是一个枚举的实例 </li>
<li>getCookies()：返回客户端的所有Cookie对象，结果是一个Cookie数组 </li>
<li>getCharacterEncoding()：返回请求中的字符编码方式</li>
<li>getContentLength()：返回请求的Body的长度 </li>
<li>getHeader(String name)：获得HTTP协议定义的文件头信息 </li>
<li>getHeaders(String name)：返回指定名字的request Header的所有值，结果是一个枚举的实例 </li>
<li>getHeaderNames()：返回所以request Header的名字，结果是一个枚举的实例 </li>
<li>getInputStream()：返回请求的输入流，用于获得请求中的数据 </li>
<li>getMethod()：获得客户端向服务器端传送数据的方法 </li>
<li>getParameter(String name)：获得客户端传送给服务器端的有name指定的参数值 </li>
<li>getParameterNames()：获得客户端传送给服务器端的所有参数的名字，结果是一个枚举的实例</li>
<li>getParameterValues(String name)：获得有name指定的参数的所有值 </li>
<li>getProtocol()：获取客户端向服务器端传送数据所依据的协议名称 </li>
<li>getQueryString()：获得查询字符串 </li>
<li>getRequestURI()：获取发出请求字符串的客户端地址 </li>
<li>getRemoteAddr()：获取客户端的IP地址 </li>
<li>getRemoteHost()：获取客户端的名字 </li>
<li>getSession([Boolean create])：返回和请求相关Session</li>
<li>getServerName()：获取服务器的名字 </li>
<li>getServletPath()：获取客户端所请求的脚本文件的路径 </li>
<li>getServerPort()：获取服务器的端口号 </li>
<li>removeAttribute(String name)：删除请求中的一个属性</li>
</ul>
<h3 id="J2EE是技术还是平台还是框架？J2EE本身是一个标准，一个为企业分布式应用的开发提供的标准-平台。"><a href="#J2EE是技术还是平台还是框架？J2EE本身是一个标准，一个为企业分布式应用的开发提供的标准-平台。" class="headerlink" title="J2EE是技术还是平台还是框架？J2EE本身是一个标准，一个为企业分布式应用的开发提供的标准 平台。"></a>J2EE是技术还是平台还是框架？J2EE本身是一个标准，一个为企业分布式应用的开发提供的标准 平台。</h3><p>J2EE本身是一个标准，一个为企业分布式应用的开发提供的标准 平台。 </p>
<p>J2EE也是一个框架，包括JDBC、JNDI、RMI、JMS、EJB、JTA等技术。</p>
<h3 id="简述synchronized和java-util-concurrent-locks-Lock的异同-？"><a href="#简述synchronized和java-util-concurrent-locks-Lock的异同-？" class="headerlink" title="简述synchronized和java.util.concurrent.locks.Lock的异同 ？"></a>简述synchronized和java.util.concurrent.locks.Lock的异同 ？</h3><p> <strong>主要相同点</strong>：Lock能完成synchronized所实现的所有功能主要不同。Lock有比synchronized更精确的线程语义和更好的性能。synchronized会自动释放锁，而Lock一定要求程序员手工释放，并且必须在fin ally从句中释放。</p>
<h3 id="Servlet执行时一般实现哪几个方法？"><a href="#Servlet执行时一般实现哪几个方法？" class="headerlink" title="Servlet执行时一般实现哪几个方法？"></a>Servlet执行时一般实现哪几个方法？</h3><ul>
<li>public void init(ServletConfig config)；</li>
<li>public ServletConfig getServletConfig()；</li>
<li>public String getServletInfo()；</li>
<li>public void service(ServletRequest request,ServletResponse response)；</li>
<li>public void destroy()</li>
</ul>
<h3 id="MVC的各个部分都有那些技术来实现-如何实现"><a href="#MVC的各个部分都有那些技术来实现-如何实现" class="headerlink" title="MVC的各个部分都有那些技术来实现?如何实现?"></a>MVC的各个部分都有那些技术来实现?如何实现?</h3><p>MVC是Model－View－Controller的简写。</p>
<p>“Model” 代表的是应用的业务逻辑（通过JavaBean，EJB组件实现）， </p>
<p>“View” 是应用的表示面（由JSP页面产生），</p>
<p>“Controller” 是提供应用的处理过程控制（一般是一个Servlet），通过这种设计模型把应用逻辑，处理过程和显示逻 辑分成不同的组件实现。这些组件可以进行交互和重用。</p>
<h3 id="jsp有哪些动作-作用分别是什么"><a href="#jsp有哪些动作-作用分别是什么" class="headerlink" title="jsp有哪些动作?作用分别是什么?"></a>jsp有哪些动作?作用分别是什么?</h3><p><strong>JSP共有以下6种基本动作</strong></p>
<p><strong>jsp:include</strong>：在页面被请求的时候引入一个文件。 </p>
<p><strong>jsp:useBean</strong>：寻找或者实例化一个JavaBean。 </p>
<p><strong>jsp:setProperty</strong>：设置JavaBean的属性。 </p>
<p><strong>jsp:getProperty</strong>：输出某个JavaBean的属性。 </p>
<p><strong>jsp:forward</strong>：把请求转到一个新的页面。</p>
<p><strong>jsp:plugin</strong>：根据浏览器类型为Java插件生成OBJECT或EMBED标记。</p>
<h2 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h2><h3 id="JDBC调用数据库的基本步骤"><a href="#JDBC调用数据库的基本步骤" class="headerlink" title="JDBC调用数据库的基本步骤"></a>JDBC调用数据库的基本步骤</h3><ul>
<li><p>导入必要的类</p>
</li>
<li><p>装入JDBC驱动程序</p>
</li>
<li><p>识别数据源</p>
</li>
<li><p>分配一个Connection对 象</p>
</li>
<li><p>分配一个Statement对象</p>
</li>
<li><p>使用Statement执行一个查询</p>
</li>
<li><p>从返回的ResultSet对象中检索数据</p>
</li>
<li><p>关闭ResultSet</p>
</li>
<li><p>关闭Statement对象</p>
</li>
<li><p>关闭Connection对象</p>
</li>
</ul>
<h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><h3 id="java中对象之间的通讯采用什么方法。"><a href="#java中对象之间的通讯采用什么方法。" class="headerlink" title="java中对象之间的通讯采用什么方法。"></a>java中对象之间的通讯采用什么方法。</h3><p>直接调用另一对象方法来进行通讯以及数据的交换。</p>
<h3 id="tcp-ip在连接是有几次握手？释放是有几次握手？"><a href="#tcp-ip在连接是有几次握手？释放是有几次握手？" class="headerlink" title="tcp/ip在连接是有几次握手？释放是有几次握手？"></a>tcp/ip在连接是有几次握手？释放是有几次握手？</h3><p>建立连接是2次,释放是3次。</p>
<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><h3 id="常用的设计模式？"><a href="#常用的设计模式？" class="headerlink" title="常用的设计模式？"></a>常用的设计模式？</h3><p>Java中的23种设计模式：<code>Factory</code>（工厂模式），</p>
<p><code>Builder</code>（建造模式）， </p>
<p><code>Factory Method</code>（工厂方法模式），</p>
<p><code>Prototype</code>（原始模型模式），</p>
<p><code>Singleton</code>（单例模式）， </p>
<p><code>Facade</code>（门面模式），</p>
<p><code>Adapter</code>（适配器模式）， </p>
<p><code>Bridge</code>（桥梁模式）， </p>
<p><code>Composite</code>（合成模式），</p>
<p><code>Decorator</code>（装饰模式）， </p>
<p><code>Flyweight</code>（享元模式）， </p>
<p><code>Proxy</code>（代理模式），</p>
<p><code>Command</code>（命令模式）， </p>
<p><code>Interpreter</code>（解释器模式）， </p>
<p><code>Visitor</code>（访问者模式），</p>
<p><code>Iterator</code>（迭代子模式），</p>
<p><code>Mediator</code>（调停者模式）， </p>
<p><code>Memento</code>（备忘录模式），</p>
<p><code>Observer</code>（观察者模式），</p>
<p><code>State</code>（状态模式），</p>
<p><code>Strategy</code>（策略模式），</p>
<p><code>Template Method</code>（模板方法模式）， </p>
<p><code>Chain Of Responsibleity</code>（责任链模式）。</p>
<p>工厂模式：工厂模式是一种经常被使用到的模式，根据工厂模式实现的 类可以根据提供的数据生成一组类中某一个类的实例，通常这一组类有一个公共的抽象父类并且实 现了相同的方法，但是这些方法针对不同的数据进行了不同的操作。首先需要定义一个基类，该类的 子类通过不同的方法实现了基类中的方法。然后需要定义一个工厂类，工厂类可以根据条件生成不同 的子类实例。当得到子类的实例后，开发人员可以调用基类中的方法而不必考虑到底返回的是哪一个 子类的实例。</p>
<h2 id="SSM"><a href="#SSM" class="headerlink" title="SSM"></a>SSM</h2><h3 id="请谈一谈Spring中自动装配的方式有哪些？"><a href="#请谈一谈Spring中自动装配的方式有哪些？" class="headerlink" title="请谈一谈Spring中自动装配的方式有哪些？"></a>请谈一谈Spring中自动装配的方式有哪些？</h3><p>- no：不进行自动装配，手动设置Bean的依赖关系。<br>- byName：根据Bean的名字进行自动装配。<br>- byType：根据Bean的类型进行自动装配。<br>- constructor：类似于byType，不过是应用于构造器的参数，如果正好有一个Bean与构造器的参数类型相同则可以自动装配，否则会导致错误。<br>- autodetect：如果有默认的构造器，则通过constructor的方式进行自动装配，否则使用byType的方式进行自动装配。</p>
<p>自动装配没有自定义装配方式那么精确，而且不能自动装配简单属性（基本类型、字符串等），在使用时应注意。</p>
<h3 id="请问Spring中Bean的作用域有哪些？"><a href="#请问Spring中Bean的作用域有哪些？" class="headerlink" title="请问Spring中Bean的作用域有哪些？"></a>请问Spring中Bean的作用域有哪些？</h3><p>在Spring的早期版本中，仅有两个作用域：singleton和prototype，前者表示Bean以单例的方式存在；后者表示每次从容器中调用Bean时，都会返回一个新的实例，prototype通常翻译为原型。</p>
<p>设计模式中的创建型模式中也有一个原型模式，原型模式也是一个常用的模式，例如做一个室内设计软件，所有的素材都在工具箱中，而每次从工具箱中取出的都是素材对象的一个原型，可以通过对象克隆来实现原型模式。Spring 2.x中针对WebApplicationContext新增了3个作用域，分别是：request（每次HTTP请求都会创建一个新的Bean）、session（同一个HttpSession共享同一个Bean，不同的HttpSession使用不同的Bean）和globalSession（同一个全局Session共享一个Bean）。</p>
<p>单例模式和原型模式都是重要的设计模式。一般情况下，无状态或状态不可变的类适合使用单例模式。在传统开发中，由于DAO持有Connection这个非线程安全对象因而没有使用单例模式；但在Spring环境下，所有DAO类对可以采用单例模式，因为Spring利用AOP和Java API中的ThreadLocal对非线程安全的对象进行了特殊处理。</p>
<h3 id="请问什么是IoC和DI？并且简要说明一下DI是如何实现的？"><a href="#请问什么是IoC和DI？并且简要说明一下DI是如何实现的？" class="headerlink" title="请问什么是IoC和DI？并且简要说明一下DI是如何实现的？"></a>请问什么是IoC和DI？并且简要说明一下DI是如何实现的？</h3><p>IoC叫控制反转，是Inversion of Control的缩写，DI（Dependency Injection）叫依赖注入，是对IoC更简单的诠释。控制反转是把传统上由程序代码直接操控的对象的调用权交给容器，通过容器来实现对象组件的装配和管理。所谓的”控制反转”就是对组件对象控制权的转移，从程序代码本身转移到了外部容器，由容器来创建对象并管理对象之间的依赖关系。</p>
<p>IoC体现了好莱坞原则 - “Don’t call me, we will call you”。依赖注入的基本原则是应用组件不应该负责查找资源或者其他依赖的协作对象。配置对象的工作应该由容器负责，查找资源的逻辑应该从应用组件的代码中抽取出来，交给容器来完成。DI是对IoC更准确的描述，即组件之间的依赖关系由容器在运行期决定，形象的来说，即由容器动态的将某种依赖关系注入到组件之中。</p>
<h3 id="请说明一下Spring中BeanFactory和ApplicationContext的区别是什么？"><a href="#请说明一下Spring中BeanFactory和ApplicationContext的区别是什么？" class="headerlink" title="请说明一下Spring中BeanFactory和ApplicationContext的区别是什么？"></a>请说明一下Spring中BeanFactory和ApplicationContext的区别是什么？</h3>
    </div>

    
    
    
<div>
      
        
      
</div>
<div>
  
    <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>
    
</div>
  
</div>
      <footer class="post-footer">
          <div class="post-tags">
              <a href="/blog/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="tag"> 面试题</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/blog/2020/10/19/oracle%E5%88%9B%E5%BB%BA%E7%94%A8%E6%88%B7%E5%B9%B6%E6%8C%87%E5%AE%9A%E8%A1%A8%E7%A9%BA%E9%97%B4/" rel="prev" title="oracle11g创建用户并指定表空间">
      <i class="fa fa-chevron-left"></i> oracle11g创建用户并指定表空间
    </a></div>
      <div class="post-nav-item">
    <a href="/blog/2020/10/23/vue%E5%AD%A6%E4%B9%A0/" rel="next" title="Vue.js学习">
      Vue.js学习 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0"><span class="nav-number">1.</span> <span class="nav-text">面试复习</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#java%E5%9F%BA%E7%A1%80"><span class="nav-number">1.1.</span> <span class="nav-text">java基础</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.1.1.</span> <span class="nav-text">面向对象和面向过程的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java-%E8%AF%AD%E8%A8%80%E6%9C%89%E5%93%AA%E4%BA%9B%E7%89%B9%E7%82%B9"><span class="nav-number">1.1.2.</span> <span class="nav-text">Java 语言有哪些特点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B3%E4%BA%8E-JVM-JDK-%E5%92%8C-JRE-%E6%9C%80%E8%AF%A6%E7%BB%86%E9%80%9A%E4%BF%97%E7%9A%84%E8%A7%A3%E7%AD%94"><span class="nav-number">1.1.3.</span> <span class="nav-text">关于 JVM JDK 和 JRE 最详细通俗的解答</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Oracle-JDK-%E5%92%8C-OpenJDK-%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="nav-number">1.1.4.</span> <span class="nav-text">Oracle JDK 和 OpenJDK 的对比</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java%E5%92%8CC-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.1.5.</span> <span class="nav-text">Java和C++的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Java-%E7%A8%8B%E5%BA%8F%E7%9A%84%E4%B8%BB%E7%B1%BB-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%92%8C%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E4%B8%BB-%E7%B1%BB%E6%9C%89%E4%BD%95%E4%B8%8D%E5%90%8C"><span class="nav-number">1.1.6.</span> <span class="nav-text">什么是 Java 程序的主类 应用程序和小程序的主 类有何不同</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Java-%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88-Java-%E8%A2%AB%E7%A7%B0%E4%BD%9C%E6%98%AF%E2%80%9C%E5%B9%B3%E5%8F%B0%E6%97%A0%E5%85%B3%E7%9A%84%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E2%80%9D%EF%BC%9F"><span class="nav-number">1.1.7.</span> <span class="nav-text">什么是 Java 虚拟机？为什么 Java 被称作是“平台无关的编程语言”？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%80%9Dstatic%E2%80%9D%E5%85%B3%E9%94%AE%E5%AD%97%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D%EF%BC%9FJava-%E4%B8%AD%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E8%A6%86%E7%9B%96-override-%E4%B8%80%E4%B8%AA-private-%E6%88%96%E8%80%85%E6%98%AF-static-%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="nav-number">1.1.8.</span> <span class="nav-text">”static”关键字是什么意思？Java 中是否可以覆盖(override)一个 private 或者是 static 的方法？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E5%9C%A8static%E7%8E%AF%E5%A2%83%E4%B8%AD%E8%AE%BF%E9%97%AE%E9%9D%9Estatic%E5%8F%98%E9%87%8F"><span class="nav-number">1.1.9.</span> <span class="nav-text">是否可以在static环境中访问非static变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java-%E6%94%AF%E6%8C%81%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AF%E8%87%AA%E5%8A%A8%E6%8B%86%E8%A3%85%E7%AE%B1%EF%BC%9F"><span class="nav-number">1.1.10.</span> <span class="nav-text">Java 支持的数据类型有哪些？什么是自动拆装箱？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java-%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95%E8%A6%86%E7%9B%96-Overriding-%E5%92%8C%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD-Overloading-%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D%EF%BC%9F"><span class="nav-number">1.1.11.</span> <span class="nav-text">Java 中的方法覆盖(Overriding)和方法重载(Overloading)是什么意思？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%87%8D%E5%86%99%E6%96%B9%E6%B3%95%E7%9A%84%E8%A7%84%E5%88%99%EF%BC%9A%EF%BC%88%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99%E4%B9%9F%E7%A7%B0%E4%B8%BA%E6%96%B9%E6%B3%95%E8%A6%86%E7%9B%96%EF%BC%89"><span class="nav-number">1.1.11.1.</span> <span class="nav-text">重写方法的规则：（方法重写也称为方法覆盖）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%80%8C%E9%87%8D%E8%BD%BD%E7%9A%84%E8%A7%84%E5%88%99"><span class="nav-number">1.1.11.2.</span> <span class="nav-text">而重载的规则</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%87%8D%E5%86%99%E4%B8%8E%E9%87%8D%E8%BD%BD%E7%9A%84%E5%8C%BA%E5%88%AB%E5%9C%A8%E4%BA%8E"><span class="nav-number">1.1.11.3.</span> <span class="nav-text">重写与重载的区别在于</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java-%E4%B8%AD%EF%BC%8C%E4%BB%80%E4%B9%88%E6%98%AF%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AF%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AF%E5%A4%8D%E5%88%B6%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%9F"><span class="nav-number">1.1.12.</span> <span class="nav-text">Java 中，什么是构造函数？什么是构造函数重载？什么是复制构造函数？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java-%E6%94%AF%E6%8C%81%E5%A4%9A%E7%BB%A7%E6%89%BF%E4%B9%88%EF%BC%9F%E6%94%AF%E6%8C%81%E5%A4%9A%E5%AE%9E%E7%8E%B0%E5%90%97%EF%BC%9F"><span class="nav-number">1.1.13.</span> <span class="nav-text">Java 支持多继承么？支持多实现吗？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E5%8F%AF%E4%BB%A5%E7%BB%A7%E6%89%BF%E6%8E%A5%E5%8F%A3%E5%90%97%EF%BC%9F%E5%A6%82%E6%9E%9C%E5%8F%AF%E4%BB%A5%E7%BB%A7%E6%89%BF-%E8%AF%B7%E5%88%97%E4%B8%BE%E4%B8%80%E4%B8%AA%E6%A1%88%E4%BE%8B%EF%BC%9F"><span class="nav-number">1.1.14.</span> <span class="nav-text">接口可以继承接口吗？如果可以继承 请列举一个案例？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">1.1.15.</span> <span class="nav-text">接口和抽象类的区别是什么？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="nav-number">1.1.15.1.</span> <span class="nav-text">接口和抽象的区别：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%80%BC%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92"><span class="nav-number">1.1.16.</span> <span class="nav-text">什么是值传递和引用传递</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#int-%E5%92%8C-Integer-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="nav-number">1.1.17.</span> <span class="nav-text">int 和 Integer 有什么区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#String%E5%92%8CStringBuffer%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.1.18.</span> <span class="nav-text">String和StringBuffer的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E5%BC%82%E5%B8%B8%E5%92%8C%E4%B8%80%E8%88%AC%E5%BC%82%E5%B8%B8%E6%9C%89%E4%BD%95%E4%B8%8D%E5%90%8C"><span class="nav-number">1.1.19.</span> <span class="nav-text">运行时异常和一般异常有何不同</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#final-finally-finalize%E7%9A%84%E5%8C%BA%E5%88%AB%E3%80%82"><span class="nav-number">1.1.20.</span> <span class="nav-text">final, finally, finalize的区别。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Overload%E5%92%8COverride%E7%9A%84%E5%8C%BA%E5%88%AB%E3%80%82"><span class="nav-number">1.1.21.</span> <span class="nav-text">Overload和Override的区别。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#swtich%E6%98%AF%E5%90%A6%E8%83%BD%E4%BD%9C%E7%94%A8%E5%9C%A8byte%E4%B8%8A%EF%BC%8C%E6%98%AF%E5%90%A6%E8%83%BD%E4%BD%9C%E7%94%A8%E5%9C%A8long%E4%B8%8A%EF%BC%8C%E6%98%AF%E5%90%A6%E8%83%BD%E4%BD%9C%E7%94%A8%E5%9C%A8String%E4%B8%8A"><span class="nav-number">1.1.22.</span> <span class="nav-text">swtich是否能作用在byte上，是否能作用在long上，是否能作用在String上?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#char%E5%9E%8B%E5%8F%98%E9%87%8F%E4%B8%AD%E8%83%BD%E4%B8%8D%E8%83%BD%E5%AD%98%E8%B4%AE%E4%B8%80%E4%B8%AA%E4%B8%AD%E6%96%87%E6%B1%89%E5%AD%97-%E4%B8%BA%E4%BB%80%E4%B9%88"><span class="nav-number">1.1.23.</span> <span class="nav-text">char型变量中能不能存贮一个中文汉字?为什么?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#java%E4%B8%AD%E6%9C%89%E5%87%A0%E7%A7%8D%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%B5%81%EF%BC%9F"><span class="nav-number">1.1.24.</span> <span class="nav-text">java中有几种类型的流？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFjava%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%8C%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0java%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%9F"><span class="nav-number">1.1.25.</span> <span class="nav-text">什么是java序列化，如何实现java序列化？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E4%BB%8E%E4%B8%80%E4%B8%AAstatic%E6%96%B9%E6%B3%95%E5%86%85%E9%83%A8%E5%8F%91%E5%87%BA%E5%AF%B9%E9%9D%9Estatic%E6%96%B9%E6%B3%95%E7%9A%84%E8%B0%83%E7%94%A8%EF%BC%9F"><span class="nav-number">1.1.26.</span> <span class="nav-text">是否可以从一个static方法内部发出对非static方法的调用？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B"><span class="nav-number">1.2.</span> <span class="nav-text">线程与进程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">1.2.1.</span> <span class="nav-text">进程和线程的区别是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%9C%89%E5%87%A0%E7%A7%8D%E4%B8%8D%E5%90%8C%E7%9A%84%E6%96%B9%E5%BC%8F%EF%BC%9F%E4%BD%A0%E5%96%9C%E6%AC%A2%E5%93%AA%E4%B8%80%E7%A7%8D%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">1.2.2.</span> <span class="nav-text">创建线程有几种不同的方式？你喜欢哪一种？为什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A6%82%E6%8B%AC%E7%9A%84%E8%A7%A3%E9%87%8A%E4%B8%8B%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%87%A0%E7%A7%8D%E5%8F%AF%E7%94%A8%E7%8A%B6%E6%80%81%E3%80%82"><span class="nav-number">1.2.3.</span> <span class="nav-text">概括的解释下线程的几种可用状态。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95%E5%92%8C%E5%90%8C%E6%AD%A5%E4%BB%A3%E7%A0%81%E5%9D%97%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">1.2.4.</span> <span class="nav-text">同步方法和同步代码块的区别是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%A8%E7%9B%91%E8%A7%86%E5%99%A8-Monitor-%E5%86%85%E9%83%A8%EF%BC%8C%E6%98%AF%E5%A6%82%E4%BD%95%E5%81%9A%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E7%9A%84%EF%BC%9F%E7%A8%8B%E5%BA%8F%E5%BA%94%E8%AF%A5%E5%81%9A%E5%93%AA%E7%A7%8D%E7%BA%A7%E5%88%AB%E7%9A%84%E5%90%8C%E6%AD%A5%EF%BC%9F"><span class="nav-number">1.2.5.</span> <span class="nav-text">在监视器(Monitor)内部，是如何做线程同步的？程序应该做哪种级别的同步？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%AD%BB%E9%94%81-deadlock-%EF%BC%9F"><span class="nav-number">1.2.6.</span> <span class="nav-text">什么是死锁(deadlock)？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E7%A1%AE%E4%BF%9D-N-%E4%B8%AA%E7%BA%BF%E7%A8%8B%E5%8F%AF%E4%BB%A5%E8%AE%BF%E9%97%AE-N-%E4%B8%AA%E8%B5%84%E6%BA%90%E5%90%8C%E6%97%B6%E5%8F%88%E4%B8%8D%E5%AF%BC%E8%87%B4%E6%AD%BB%E9%94%81%EF%BC%9F"><span class="nav-number">1.2.7.</span> <span class="nav-text">如何确保 N 个线程可以访问 N 个资源同时又不导致死锁？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5%E6%9C%89%E4%BD%95%E5%BC%82%E5%90%8C%EF%BC%8C%E5%9C%A8%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E5%88%86%E5%88%AB%E4%BD%BF%E7%94%A8%E4%BB%96%E4%BB%AC%EF%BC%9F%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E%E3%80%82"><span class="nav-number">1.2.8.</span> <span class="nav-text">同步和异步有何异同，在什么情况下分别使用他们？举例说明。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%AF%E5%8A%A8%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E6%98%AF%E7%94%A8run-%E8%BF%98%E6%98%AFstart"><span class="nav-number">1.2.9.</span> <span class="nav-text">启动一个线程是用run()还是start()?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%B4%E5%87%BA%E6%95%B0%E6%8D%AE%E8%BF%9E%E6%8E%A5%E6%B1%A0%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">1.2.10.</span> <span class="nav-text">说出数据连接池的工作机制是什么?</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9B%86%E5%90%88"><span class="nav-number">1.3.</span> <span class="nav-text">集合</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Java-%E9%9B%86%E5%90%88%E7%B1%BB%E6%A1%86%E6%9E%B6%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%8E%A5%E5%8F%A3%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-number">1.3.1.</span> <span class="nav-text">Java 集合类框架的基本接口有哪些？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9B%86%E5%90%88%E7%B1%BB%E6%B2%A1%E6%9C%89%E5%AE%9E%E7%8E%B0-Cloneable-%E5%92%8C-Serializable-%E6%8E%A5%E5%8F%A3%EF%BC%9F"><span class="nav-number">1.3.2.</span> <span class="nav-text">为什么集合类没有实现 Cloneable 和 Serializable 接口？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%AD%E4%BB%A3%E5%99%A8-Iterator-%EF%BC%9F"><span class="nav-number">1.3.3.</span> <span class="nav-text">什么是迭代器(Iterator)？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Iterator-%E5%92%8C-ListIterator-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">1.3.4.</span> <span class="nav-text">Iterator 和 ListIterator  的区别是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java-%E4%B8%AD%E7%9A%84-HashMap-%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">1.3.5.</span> <span class="nav-text">Java  中的 HashMap 的工作原理是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#hashCode-%E5%92%8C-equals-%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7%E4%BD%93%E7%8E%B0%E5%9C%A8%E4%BB%80%E4%B9%88%E5%9C%B0%E6%96%B9%EF%BC%9F"><span class="nav-number">1.3.6.</span> <span class="nav-text">hashCode()和 equals()方法的重要性体现在什么地方？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HashMap-%E5%92%8C-Hashtable-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">1.3.7.</span> <span class="nav-text">HashMap 和 Hashtable 有什么区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%BB%84-Array-%E5%92%8C%E5%88%97%E8%A1%A8-ArrayList-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%BA%94%E8%AF%A5%E4%BD%BF%E7%94%A8-Array-%E8%80%8C%E4%B8%8D%E6%98%AFArrayList-%EF%BC%9F"><span class="nav-number">1.3.8.</span> <span class="nav-text">数组(Array)和列表(ArrayList)有什么区别？什么时候应该使用 Array 而不是ArrayList ？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ArrayList-%E5%92%8C-LinkedList-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">1.3.9.</span> <span class="nav-text">ArrayList 和 LinkedList 有什么区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Comparable-%E5%92%8C-Comparator-%E6%8E%A5%E5%8F%A3%E6%98%AF%E5%B9%B2%E4%BB%80%E4%B9%88%E7%9A%84%EF%BC%9F%E5%88%97%E5%87%BA%E5%AE%83%E4%BB%AC%E7%9A%84%E5%8C%BA%E5%88%AB%E3%80%82"><span class="nav-number">1.3.10.</span> <span class="nav-text">Comparable 和 Comparator 接口是干什么的？列出它们的区别。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Java-%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97-Priority-Queue-%EF%BC%9F"><span class="nav-number">1.3.11.</span> <span class="nav-text">什么是 Java 优先级队列(Priority Queue)？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E6%9D%83%E8%A1%A1%E6%98%AF%E4%BD%BF%E7%94%A8%E6%97%A0%E5%BA%8F%E7%9A%84%E6%95%B0%E7%BB%84%E8%BF%98%E6%98%AF%E6%9C%89%E5%BA%8F%E7%9A%84%E6%95%B0%E7%BB%84%EF%BC%9F"><span class="nav-number">1.3.12.</span> <span class="nav-text">如何权衡是使用无序的数组还是有序的数组？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HashSet-%E5%92%8C-TreeSet-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">1.3.13.</span> <span class="nav-text">HashSet 和 TreeSet 有什么区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Set%E9%87%8C%E7%9A%84%E5%85%83%E7%B4%A0%E6%98%AF%E4%B8%8D%E8%83%BD%E9%87%8D%E5%A4%8D%E7%9A%84%EF%BC%8C%E9%82%A3%E4%B9%88%E7%94%A8%E4%BB%80%E4%B9%88%E6%96%B9%E6%B3%95%E6%9D%A5%E5%8C%BA%E5%88%86%E9%87%8D%E5%A4%8D%E4%B8%8E%E5%90%A6%E5%91%A2-%E6%98%AF%E7%94%A8-%E8%BF%98%E6%98%AFequals-%E5%AE%83%E4%BB%AC%E6%9C%89%E4%BD%95%E5%8C%BA%E5%88%AB"><span class="nav-number">1.3.14.</span> <span class="nav-text">Set里的元素是不能重复的，那么用什么方法来区分重复与否呢? 是用&#x3D;&#x3D;还是equals()? 它们有何区别?</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JVM"><span class="nav-number">1.4.</span> <span class="nav-text">JVM</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Java%E4%B8%AD%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%89%E4%BB%80%E4%B9%88%E7%9B%AE%E7%9A%84%EF%BC%9F%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E8%BF%9B%E8%A1%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%EF%BC%9F"><span class="nav-number">1.4.1.</span> <span class="nav-text">Java中垃圾回收有什么目的？什么时候进行垃圾回收？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#System-gc-%E5%92%8C-Runtime-gc-%E4%BC%9A%E5%81%9A%E4%BB%80%E4%B9%88%E4%BA%8B%E6%83%85%EF%BC%9F"><span class="nav-number">1.4.2.</span> <span class="nav-text">System.gc()和 Runtime.gc()会做什么事情？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java-%E5%A0%86%E7%9A%84%E7%BB%93%E6%9E%84%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E5%AD%90%E7%9A%84%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AF%E5%A0%86%E4%B8%AD%E7%9A%84%E6%B0%B8%E4%B9%85%E4%BB%A3-Perm-Gen-space"><span class="nav-number">1.4.3.</span> <span class="nav-text">Java 堆的结构是什么样子的？什么是堆中的永久代(Perm Gen space)?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%B2%E8%A1%8C-serial-%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%90%9E%E5%90%90%E9%87%8F-throughput-%E6%94%B6%E9%9B%86%E5%99%A8%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">1.4.4.</span> <span class="nav-text">串行(serial)收集器和吞吐量(throughput)收集器的区别是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%A8-Java-%E4%B8%AD%EF%BC%8C%E5%AF%B9%E8%B1%A1%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%8F%AF%E4%BB%A5%E8%A2%AB%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%EF%BC%9F"><span class="nav-number">1.4.5.</span> <span class="nav-text">在 Java  中，对象什么时候可以被垃圾回收？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JVM-%E7%9A%84%E6%B0%B8%E4%B9%85%E4%BB%A3%E4%B8%AD%E4%BC%9A%E5%8F%91%E7%94%9F%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E4%B9%88%EF%BC%9F"><span class="nav-number">1.4.6.</span> <span class="nav-text">JVM  的永久代中会发生垃圾回收么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8F%8F%E8%BF%B0%E4%B8%80%E4%B8%8BJVM%E5%8A%A0%E8%BD%BDclass%E6%96%87%E4%BB%B6%E7%9A%84%E5%8E%9F%E7%90%86%E6%9C%BA%E5%88%B6"><span class="nav-number">1.4.7.</span> <span class="nav-text">描述一下JVM加载class文件的原理机制?</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JavaWeb"><span class="nav-number">1.5.</span> <span class="nav-text">JavaWeb</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%B4%E5%87%BAServlet%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%8C%E5%B9%B6%E8%AF%B4%E5%87%BAServlet%E5%92%8CCGI%E7%9A%84%E5%8C%BA%E5%88%AB%E3%80%82"><span class="nav-number">1.5.1.</span> <span class="nav-text">说出Servlet的生命周期，并说出Servlet和CGI的区别。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JSP%E4%B8%AD%E5%8A%A8%E6%80%81INCLUDE%E4%B8%8E%E9%9D%99%E6%80%81INCLUDE%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">1.5.2.</span> <span class="nav-text">JSP中动态INCLUDE与静态INCLUDE的区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8assert%E3%80%82"><span class="nav-number">1.5.3.</span> <span class="nav-text">什么时候用assert。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java%E6%9C%89%E6%B2%A1%E6%9C%89goto"><span class="nav-number">1.5.4.</span> <span class="nav-text">Java有没有goto?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JSP%E7%9A%84%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%8F%8A%E6%96%B9%E6%B3%95%E3%80%82"><span class="nav-number">1.5.5.</span> <span class="nav-text">JSP的内置对象及方法。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E8%B0%83%E7%94%A8doGet-%E5%92%8CdoPost-%EF%BC%9F"><span class="nav-number">1.5.6.</span> <span class="nav-text">什么情况下调用doGet()和doPost()？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E7%8E%B0%E5%AE%9Eservlet%E7%9A%84%E5%8D%95%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.5.7.</span> <span class="nav-text">如何现实servlet的单线程模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JSP%E5%92%8CServlet%E6%9C%89%E5%93%AA%E4%BA%9B%E7%9B%B8%E5%90%8C%E7%82%B9%E5%92%8C%E4%B8%8D%E5%90%8C%E7%82%B9%EF%BC%8C%E4%BB%96%E4%BB%AC%E4%B9%8B%E9%97%B4%E7%9A%84%E8%81%94%E7%B3%BB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">1.5.8.</span> <span class="nav-text">JSP和Servlet有哪些相同点和不同点，他们之间的联系是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#jsp%E7%9A%84%E5%9B%9B%E7%A7%8D%E8%8C%83%E5%9B%B4"><span class="nav-number">1.5.9.</span> <span class="nav-text">jsp的四种范围</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Request%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%BB%E8%A6%81%E6%96%B9%E6%B3%95"><span class="nav-number">1.5.10.</span> <span class="nav-text">Request对象的主要方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#J2EE%E6%98%AF%E6%8A%80%E6%9C%AF%E8%BF%98%E6%98%AF%E5%B9%B3%E5%8F%B0%E8%BF%98%E6%98%AF%E6%A1%86%E6%9E%B6%EF%BC%9FJ2EE%E6%9C%AC%E8%BA%AB%E6%98%AF%E4%B8%80%E4%B8%AA%E6%A0%87%E5%87%86%EF%BC%8C%E4%B8%80%E4%B8%AA%E4%B8%BA%E4%BC%81%E4%B8%9A%E5%88%86%E5%B8%83%E5%BC%8F%E5%BA%94%E7%94%A8%E7%9A%84%E5%BC%80%E5%8F%91%E6%8F%90%E4%BE%9B%E7%9A%84%E6%A0%87%E5%87%86-%E5%B9%B3%E5%8F%B0%E3%80%82"><span class="nav-number">1.5.11.</span> <span class="nav-text">J2EE是技术还是平台还是框架？J2EE本身是一个标准，一个为企业分布式应用的开发提供的标准 平台。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%80%E8%BF%B0synchronized%E5%92%8Cjava-util-concurrent-locks-Lock%E7%9A%84%E5%BC%82%E5%90%8C-%EF%BC%9F"><span class="nav-number">1.5.12.</span> <span class="nav-text">简述synchronized和java.util.concurrent.locks.Lock的异同 ？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Servlet%E6%89%A7%E8%A1%8C%E6%97%B6%E4%B8%80%E8%88%AC%E5%AE%9E%E7%8E%B0%E5%93%AA%E5%87%A0%E4%B8%AA%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="nav-number">1.5.13.</span> <span class="nav-text">Servlet执行时一般实现哪几个方法？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MVC%E7%9A%84%E5%90%84%E4%B8%AA%E9%83%A8%E5%88%86%E9%83%BD%E6%9C%89%E9%82%A3%E4%BA%9B%E6%8A%80%E6%9C%AF%E6%9D%A5%E5%AE%9E%E7%8E%B0-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.5.14.</span> <span class="nav-text">MVC的各个部分都有那些技术来实现?如何实现?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#jsp%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8A%A8%E4%BD%9C-%E4%BD%9C%E7%94%A8%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">1.5.15.</span> <span class="nav-text">jsp有哪些动作?作用分别是什么?</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JDBC"><span class="nav-number">1.6.</span> <span class="nav-text">JDBC</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#JDBC%E8%B0%83%E7%94%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%AD%A5%E9%AA%A4"><span class="nav-number">1.6.1.</span> <span class="nav-text">JDBC调用数据库的基本步骤</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C"><span class="nav-number">1.7.</span> <span class="nav-text">网络</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#java%E4%B8%AD%E5%AF%B9%E8%B1%A1%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E8%AE%AF%E9%87%87%E7%94%A8%E4%BB%80%E4%B9%88%E6%96%B9%E6%B3%95%E3%80%82"><span class="nav-number">1.7.1.</span> <span class="nav-text">java中对象之间的通讯采用什么方法。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#tcp-ip%E5%9C%A8%E8%BF%9E%E6%8E%A5%E6%98%AF%E6%9C%89%E5%87%A0%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%9F%E9%87%8A%E6%94%BE%E6%98%AF%E6%9C%89%E5%87%A0%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%9F"><span class="nav-number">1.7.2.</span> <span class="nav-text">tcp&#x2F;ip在连接是有几次握手？释放是有几次握手？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.8.</span> <span class="nav-text">设计模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9F"><span class="nav-number">1.8.1.</span> <span class="nav-text">常用的设计模式？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SSM"><span class="nav-number">1.9.</span> <span class="nav-text">SSM</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%B7%E8%B0%88%E4%B8%80%E8%B0%88Spring%E4%B8%AD%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-number">1.9.1.</span> <span class="nav-text">请谈一谈Spring中自动装配的方式有哪些？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%B7%E9%97%AESpring%E4%B8%ADBean%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-number">1.9.2.</span> <span class="nav-text">请问Spring中Bean的作用域有哪些？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%B7%E9%97%AE%E4%BB%80%E4%B9%88%E6%98%AFIoC%E5%92%8CDI%EF%BC%9F%E5%B9%B6%E4%B8%94%E7%AE%80%E8%A6%81%E8%AF%B4%E6%98%8E%E4%B8%80%E4%B8%8BDI%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F"><span class="nav-number">1.9.3.</span> <span class="nav-text">请问什么是IoC和DI？并且简要说明一下DI是如何实现的？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%B7%E8%AF%B4%E6%98%8E%E4%B8%80%E4%B8%8BSpring%E4%B8%ADBeanFactory%E5%92%8CApplicationContext%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">1.9.4.</span> <span class="nav-text">请说明一下Spring中BeanFactory和ApplicationContext的区别是什么？</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="白小纯"
      src="/blog/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">白小纯</p>
  <div class="site-description" itemprop="description">不忘初心，方得始终</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/blog/archives/">
        
          <span class="site-state-item-count">12</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/blog/categories/">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/blog/tags/">
          
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="{fa fa-star"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">白小纯</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">252k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">3:50</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/blog/lib/anime.min.js"></script>
  <script src="/blog/lib/velocity/velocity.min.js"></script>
  <script src="/blog/lib/velocity/velocity.ui.min.js"></script>

<script src="/blog/js/utils.js"></script>

<script src="/blog/js/motion.js"></script>


<script src="/blog/js/schemes/pisces.js"></script>


<script src="/blog/js/next-boot.js"></script>




  




  
<script src="/blog/js/local-search.js"></script>













  

  

<script src="/blog/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"/blog/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":70,"height":120},"mobile":{"show":true},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
